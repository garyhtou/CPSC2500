# Gary Tou
# HW5, Smallest Five
# Prints out the 5 smallest inputed numbers

# ===== CODE =====

                lli r3 0  # data array element counter
                in r1  # user input (first input)

                # check if the input is less than zero
                bez r1 &START  # Jump if the number is >= zero
                bgz r1 &START

                # If the jump above was not made, the input number is < zero
                lli r2 0
                out r2  # output zero
                .halt

                # Set up array information and save the first element
START:          lli r2 &ARR  # save array starting memory address
                lui r2 &ARR
                sw r1 r2 0  # index zero, because it's the first element
                addi r2 r2 1  # increment the index
                addi r3 r3 1  # increment the array element counter

                # Loop for collecting additional elements
INPUT:          in r1
                bez r1 &INPUTCONT  # Continue if the input was zero or greater
                bgz r1 &INPUTCONT
                bez r0 &CALC  # Since the input was not >= 0, it is < 0. Jump to
                # the calculation (figure out the smallest numbers)
INPUTCONT:      sw r1 r2 0 # Save the input for the current array index
                addi r2 r2 1  # increment the index
                addi r3 r3 1  # increment the array element counter
                bez r0 &INPUT  # Jump to the input again

                # Find the five smallest numbers in the array
                # r3 contains the number of array elements
CALC:           lli r2 &ARR  # data array starting memory address
                lui r2 &ARR
                lli r4 5  # max elements to print
                sub r1 r4 r3  # number of elements shy of max elements to
                # print (5)
                bgz r1 &LESSTHANFIVE  # Jump if there are less than 5 elements

                # If the jump above was not made, there are 5 or more elements
                #   r2 contains the data array starting memory address
                #   r3 contains the number of elements
RLOOP:          lli r1 &RESULT  # result array starting memory address. RLOOP is
                # short for Results Loop
                lui r1 &RESULT  # this will be incremented by the loop
RLOOPBODY:      lli r4 &RESULT  # result array starting memory address. LOOP
                # CHECK CONDITION
                lui r4 &RESULT
                addi r4 r4 5   # ending memory address of result array
                sub r4 r1 r4  # loops left (negative)
                bez r4 &RLOOPEND  # Jump if the loop is done
                bgz r4 &RLOOPEND

                # If the code is here, there are still loops left
                bez r0 &DLOOP  # Jump to nested for loop (DLOOP is short for
                # data array loop)
RLOOPCONT:      sw r4 r1 0  # Store the small number in the current result array
                # element
                lli r5 -1  # Store -1 in the element index of the data array
                # This signifies that the element has been removed (already used
                # as one of the smallest numbners)
                sw r5 r7 0

                # Now that all of the data processing has been done of this
                # results array index, let's increment and begin the next loop
                # interation.
                addi r1 r1 1  # increment the memory address of the result array
                bez r0 &RLOOPBODY  # jump to next loop iteration
RLOOPEND:       bez r0 &PRINTFIVE  # Jump to print the five smallest numbers


# THE DLOOP (DATA LOOP) is only responsible for finding the small number.
# After running DLOOP, r4 will contain the smallest number, and r7 will contain
# it's index in the data array.
DLOOP:          lli r2 &ARR  # data array starting memory address
                lui r2 &ARR  # will be incremented by the loop
                lli r4 -1  # default smallest number
                lli r7 -1 # default smallest number memory address
DLOOPBODY:      lli r5 &ARR  # data array starting memory address. LOOP CHECK
                # CONDITION
                lui r5 &ARR
                add r5 r5 r3  # data array ending memory address
                sub r5 r2 r5  # loops left (negative)
                bez r5 &DLOOPEND  # Jump if the loop is done
                bgz r5 &DLOOPEND

                # If the code is here, there are still loops left
                # CHECK IF ELEMENT WAS REMOVED
                lw r5 r2 0  # load the current data array element
                addi r5 r5 1  # add 1 to the number
                bez r5 &DLOOPNEXT  # If this jump is made, it means that the
                # current data array element is equal to -1. In otherwords, that
                # element was previously removed.

                # If the code is here, the current data array element was not
                # removed. Therefore, we can consider it for whether it's the
                # smallest number left in the data array.
                lw r5 r2 0  # re-load the current data array element

                # Initialize the smallest number if it is -1
                lli r6 0
                add r6 r6 r4
                addi r6 r6 1  # Add one to the current smallest number
                bez r6 &DLOOPNEW  # If a zero, set the current as the smallest

                # Check if current number is actually smaller
                sub r6 r4 r5  # If (smallest - current) > 0, then we have a new
                # smallest number.
                bgz r6 &DLOOPNEW  # Jump to setting the new smallest number
                bez r0 &DLOOPNEXT  # Jump to the next loop iteration
DLOOPNEW:       lli r4 0  # Set r4 (smallest) equal to r5 (current data array
                # element)
                add r4 r4 r5
                lli r7 0  # Set r7 (smallest memory address) equal to r2
                # (current array element)
                add r7 r7 r2
                bez r0 &DLOOPNEXT  # Jump to the next loop iteration
DLOOPNEXT:      addi r2 r2 1  # increment the memory address of the data array
                bez r0 &DLOOPBODY  # jump to start of body of loop
DLOOPEND:       bez r0 &RLOOPCONT  # return back to RLOOP


# ===== PRINTING LOOPS =====

                # LESSTHANFIVE prints out the results when there are less than 5
                # elements in the data array.
                # r3 contains the number of array elements
LESSTHANFIVE:   lli r1 0  # printing loop counter
LTFLOOP:        lw r4 r2 0  # load current element
                out r4  # output the current element
                addi r1 r1 1  # increment the loop counter
                addi r2 r2 1  # increment the array element memory address
                sub r5 r3 r1  # number of loops left
                bgz r5 &LTFLOOP  # Jump to next iteration of loop if there
                # are > 0 loops left
                .halt  # stop program if there are no printing loops left

                # PRINTFIVE prints out the full results array (5 elements)
                # The results array now contains the 5 smallest numbers in the
                # array.
PRINTFIVE:      lli r1 &RESULT  # result array starting memory address
                lui r1 &RESULT  # will be incremented by the loop
PRINTFIVEBODY:  lli r2 &RESULT  # LOOP CHECK CONDITION
                lui r2 &RESULT
                addi r2 r2 5  # ending memory address of result array
                sub r2 r1 r2  # loops left (negative)
                bez r2 &PRINTFIVEEND  # Jump if the loop is done
                bgz r2 &PRINTFIVEEND

                # If the code is here, there are still loops left
                lw r2 r1 0  # load the current result array element
                out r2
                addi r1 r1 1  # increment the memory address of the result array
                bez r0 &PRINTFIVEBODY  # jump to next loop iteration
PRINTFIVEEND:   .halt  # stop the program. we are done!!

# ===== DATA =====

RESULT:         .fill -1  # index 0
                .fill -1  # index 1
                .fill -1  # index 2
                .fill -1  # index 3
                .fill -1  # index 4

# Growing data array. Do not place variables after this
ARR:            .fill 0
